Клонирование удаленного репозитория
---
В папке в которой будет осуществляться работа на проектов выполнить команду
```bash
git clone <ссылка на репозиторий SSH>
```

Проверить, что связь между репозиториями была создана можно при помощи команды
```bash
git remote -v
```
Перед этим нужно войти в папку проекта.

Клонирование чужого репозитория без прав на его изменения
---
Для работы с чужим репозиторием, когда нет прав на его изменение, его необходимо forkнуть
к себе в репозиторий и клонирование проводить из своего, а не чужого репозитория.
В процессе fork'а создается копия всех папок, коммитов и веток.

Работа с ветками проекта
---
Просмотр всех веток проетка. У ветки в которой находишься стоит *
```bash
git branch
```

Создать новую ветку проекта от текущей ветки, в которой находишься
```bash
git branch <имя_ветки>
```
_Имя ветки создается с учетом правил: feature/<name> для новых разработок и
bugfix/<name> для исправления ошибок в коде_

Переключиться на другу ветку, которая была ранее создана
```bash
git checkout <имя_ветки>
или
git switch <имя_ветки>
```
Создать и сразу перейти в новую созданную ветку можно при помощи команды
```bash
git checkout -b <Имя_ветки>
```

Просмотр удаленных веток
---
При помощи команды 
```bash
git branch -a
```
Можно просмотреть все ветки, которые есть в репозитории. Без флага _-a_ будут
отображены только локальные ветки. С флагом будут показаны и ветки, которые
есть в удаленном репозитории.
Перед именем веток, которые находятся в удаленном репозитории будет стоиять
префикс **remotes/origin**. Основаная ветка в удаленном репозитории будет
указана как **remotes/origin/HEAD -> origin/main**.

Сравнение веток
---
Сравнение содержания и изменений двух веток можно сделать при помощи команды
```bash
git diff <ветка_из_какой_ветки_сделали> <ветка_в_которой_изменения>
```
То есть мы можно посмотреть, что именно нам надо сделать в первой ветке, чтобы
получить состояние второй ветки. Если их поменять местами, тсравнение будет происходит
в отношении изменений как превратить вторую ветку(ранее) в первую ветку(ранее).
_Вместо одной их веток можно указать коммит через- хэш или HEAD_. Сравнение будет идти
между текущим состоянием ветки и коммитом в другой ветке и наоборот, в зависимости от из
положения.

При попощи ~ можно двигаться при сравнении по истории коммитов.
**HEAD** или **HEAD~0** - это последний сделанный коммит
**HEAD~1** или **HEAD~** - это коммит сделанный ДО последнего
**HEAD~2** - коммит за два до последнего и т.д.
Вместо HEAD также можно указывать имя ветки
```bash
git diff HEAD~4 HEAD~2
git diff master~4 master~2
```

Слияние веток fast-forward
---
Слияние, при котором между ветками нет конфликтов и истории двух веток находятся на однйо прямой, т.е. одна
ветка продолжает историю, начатую другой
```bash
переходим в ветку, в которую будем вливать ветку
git checkout master/<имя_ветки>
git merge <имя_ветки_которую вливаем>
```

Удаление веток
---
Удалить ветку локально, на GitHub она не удалится, если ее удалить локально можно при помози команд
```bash
удалит ветку, только если ее слили с другой веткой
git branch -d <имя_ветки>
удалит ветку в любом случае
git branch -D <имя_ветки>
```
_Удалить ветку можно только если не находишься в данной ветке._
